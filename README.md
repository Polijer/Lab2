## Отчет по лабораторной работе № 1

#### № группы: `ПМ-2401`

#### Выполнил: `Никитин Иван Николаевич`

#### Вариант: `18`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

>Вариант 18
Напишите программу на Java, которая выполняет следующие действия
с одномерным массивом натуральных чисел, включая проверку чисел на
простоту:
>1. Считывает с консоли число N, затем N целых чисел и заполняет
   массив размером N.
>2. Переставляет элементы массива таким образом, чтобы сначала располагались все простые числа в порядке возрастания, затем все составные числа в порядке убывания. Если числа имеют одинаковый
   статус (оба простые или оба составные), сортирует их по соответствующему порядку.
>3. Находит и выводит количество простых чисел в массиве.
>4. Выводит элементы массива, заменяя простые числа на слово «Простое», а составные числа на слово «Составное».
>5. Заменяет каждое число в массиве на сумму его цифр и выводит
   полученный массив.


Данную задачу можно разделить на 3 подзадачи:
1. Написать функцию, которая получает на вход целое число, а возвращает 'True' если число простое, и 'False' если нет.
2. Написать алгоритм сортировки.
3. Написать цикл для замены каждого числа суммой его цифр.


### 2. Входные и выходные данные

#### Данные на вход

На вход программа получает размер массива, и его элементы. Размер массива - натуральное число, элементы массива - целые числа.

|                        | Тип               | min значение    | max значение     |
|------------------------|-------------------|-----------------|------------------|
| N (Число 1)            | Натуральное число | 0               | 2<sup>31</sup>-1 |
| Y (Числа 2, 3,...,N+1) | Целые числа       | -2<sup>31</sup> | 2<sup>31</sup>-1 |

#### Данные на выход

На выход программа даёт:
- отсортированный массив(из тех же элементов, что и массив на вход)
- неотрицательное число
- массив из строк 'Простое', 'Составное' или 'Единица'
- массив из целых чисел

|          | Тип                   | min значение | max значение     |
|----------|-----------------------|--------------|------------------|
| Массив 1 | Целочисленный массив  | -            | -                |
| Число 1  | Неотрицательное число | 0            | 2<sup>31</sup>-1 |
| Массив 2 | Массив из строк       | -            | -                |
| Массив 3 | Целочисленный массив  | -            | -                |

### 3. Выбор структуры данных

Программа получает натуральное число и несколько целых элементов.

|            | название переменной | Тип (в Java) | 
|------------|---------------------|--------------|
| N (Число)  | `n`                 | `int`        |
| A (Массив) | `a`                 | `int[]`      | 

Результат для первого вывода храниться в отдельном массиве, т.к. далее, для других выводов, понадобится изначальный массив.


### 4. Алгоритм

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает число N и N элементов массива.

2. **Проверка на простое число:**  
   Проверяем, больше ли число 1, если нет, то возвращаем 'False'. Если да, то с помощью цикла со счётчиком, проверяем делимость числа, на все числа от 2 до квадратного корня числа.
Если в любой момент число делиться с остатком 0, то функция возвращает 'False' и прекращает работу. Иначе функция возвращает 'True'.

3. **Алгоритм сортировки:**

    Для этой задачи я выбрал алгоритм сортировки выбором, который является не самым оптимальным вариантом, но является наиболее простым в написании. Я решил не писать функцию для него, т.к. он применяется в программе всего два раза, и при этом сортирует в разном порядке (по возрастанию и по убыванию).

4. **Вывод результата:**  
 На экран выводятся результаты.

### 5. Программа

```java
import java.io.IOException;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.Scanner;
public class Lab2 {
   public static Scanner in = new Scanner(System.in);
   public static PrintStream out = System.out;
   public static boolean isPrime(int a){   //функция проверки число на простое
      boolean res = true;
      if (a <= 1) res = false;
      else {
         for (int i = 2; i <= (int) Math.sqrt(a); i++) {
            if (a % i == 0) {
               res = false;
               break;
            }
         }
      }
      return res;
   }
   public static void main(String[] args) throws IOException {
      int n = in.nextInt();
      int[] a = new int[n];
      int[] prime = new int[n]; //пустой массив для хранения результатов первого пункта
      int j = 0;
      for (int i = 0; i < n; i++) {
         a[i] = in.nextInt();
      }
      for (int i : a) {   //подсчёт количества простых чисел в массиве и заполнение 
         // результирующего массива простыми числами
         if (isPrime(i)) {
            prime[j] = i;
            j++;
         }
      }
      int l = j;
      for (int i : a) {   //заполнение результирующего массива не простыми числами
         if (!isPrime(i)) {
            prime[l] = i;
            l++;
         }
      }
      for (int i = 0; i < j - 1; i++) {   //сортировка методом выбора первой части массива (простых чисел)
         int min = i;
         for (int k = i + 1; k < j; k++) {
            if (prime[min] > prime[k]) {
               min = k;
            }
         }
         if (min != i) {
            int ram = prime[i];
            prime[i] = prime[min];
            prime[min] = ram;
         }
      }
      for (int i = j - 1; i < prime.length - 1; i++) {    //сортировка методом выбора второй части массива
         int max = i;
         for (int k = i + 1; k < prime.length; k++) {
            if (prime[max] < prime[k]) {
               max = k;
            }
         }
         if (max != i) {
            int ram = prime[i];
            prime[i] = prime[max];
            prime[max] = ram;
         }
      }
      for (int i : prime) out.print(i + " "); //вывод результирующего массива
      out.println("\n" + j);  //вывод количества простых чисел
      for (int i : a) {   //вывод статуса каждого числа в изначальном массиве
         if(isPrime(i)) out.print("Простое ");
         else if (i == 1) out.print("Единица ");
         else out.print("Составное ");
      }
      for (int i = 0; i < a.length; i++) {    //замена каждого элемента его суммой цифр
         int sum = 0;
         while (a[i] != 0) {
            sum += Math.abs(a[i]%10);
            a[i] /= 10;
         }
         a[i] = sum;
      }
      out.print("\n");
      for (int i : a) out.print(i + " "); //вывод результирующего массива
   }
}
```

### 6. Анализ правильности решения

Программа работает корректно на всем множестве решений с учетом ограничений.

1. Тест на работоспособность:

    - **Input**:
        ```
        10
      1 2 3 4 5 6 7 8 9 10
      
        ```

    - **Output**:
        ```
        2 3 5 10 9 8 7 6 4 1 
      4
      Единица Простое Простое Составное Простое Составное Простое Составное Составное Составное
      1 2 3 4 5 6 7 8 9 1
      ```

2. Тест на отсутствие простых:

    - **Input**:
        ```
        10
        1 4 6 8 10 12 -2 -10 9 48832
        ```

    - **Output**:
        ```
        48832 12 10 9 8 6 4 1 -2 -10 
        0
        Единица Составное Составное Составное Составное Составное Составное Составное Составное Составное
        1 4 6 8 1 3 2 1 9 25
       ```

3. Тест на отсутствие составных:

    - **Input**:
        ```
        10
        19 17 2 3 7 11 41 13 5 19
        ```

    - **Output**:
        ```
        2 3 5 7 11 13 17 19 19 41 
        10
        Простое Простое Простое Простое Простое Простое Простое Простое Простое Простое
        10 8 2 3 7 2 5 4 5 10
        ```

4. Тест на 1:

    - **Input**:
        ```
        1
        1
        ```

    - **Output**:
        ```
        1 
        0
        Единица
        1
        ```
